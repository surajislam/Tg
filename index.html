import os
import json
import uuid
from flask import Flask, render_template, request, redirect, url_for, session, jsonify
from datetime import datetime, timedelta

# --- CONFIGURATION ---
app = Flask(__name__)
# SECRET_KEY is essential for session management (like login)
# Set this as an Environment Variable on Koyeb or use a strong generated key
app.secret_key = os.environ.get("FLASK_SECRET_KEY", "your_strong_default_secret_key_here") 

# Database paths (assuming they are in the root directory)
ADMIN_DB_FILE = 'admin_database.json'
SEARCHED_DB_FILE = 'searched_usernames.json'

# --- CONSTANTS ---
SEARCH_PRICE = 30
UNLIMITED_ACCESS_CODE = "SBSIMPLE00" # <-- Aapka Secret Code

# Koyeb uses the $PORT environment variable
PORT = int(os.environ.get('PORT', 5000))

# --- DATABASE HANDLERS ---

def load_db(file_path):
    """Loads JSON data from a file."""
    if not os.path.exists(file_path):
        if file_path == ADMIN_DB_FILE:
            return {}
        return []
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading {file_path}: {e}")
        if file_path == ADMIN_DB_FILE:
            return {}
        return []

def save_db(data, file_path):
    """Saves JSON data to a file."""
    try:
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=4)
        return True
    except Exception as e:
        print(f"Error saving {file_path}: {e}")
        return False

# --- AUTHENTICATION & SESSION MANAGEMENT ---

def is_logged_in():
    """Checks if a user is logged in."""
    return 'user_id' in session

def get_user_data(user_id):
    """Retrieves user data from the admin database."""
    admin_db = load_db(ADMIN_DB_FILE)
    return admin_db.get(str(user_id))

def get_current_user():
    """Returns the current user's data or None."""
    if is_logged_in():
        return get_user_data(session['user_id'])
    return None

# --- NEW: COUPON CODE AND ACCESS LOGIC ---

def grant_unlimited_access(user_id):
    """Marks a user as having permanent, unlimited access in the database."""
    admin_db = load_db(ADMIN_DB_FILE)
    
    # Ensure user exists before updating
    user_data = admin_db.get(str(user_id))
    if not user_data:
        # User not found (shouldn't happen if they are logged in)
        return False
        
    # Grant unlimited access (set balance very high or use a flag)
    # Using a flag (is_unlimited) is better than maxing out balance
    user_data['is_unlimited'] = True 
    user_data['balance'] = 99999999 # Optional: Set a massive balance for display
    user_data['unlimited_activated'] = datetime.now().isoformat()
    
    admin_db[str(user_id)] = user_data
    return save_db(admin_db, ADMIN_DB_FILE)

# --- FLASK ROUTES ---

@app.route('/')
def dashboard():
    if not is_logged_in():
        return redirect(url_for('login'))
    
    user = get_current_user()
    if not user:
        return redirect(url_for('logout')) # Should not happen if DB is fine
        
    # Render the index.html template with user data
    return render_template(
        'index.html', 
        user_name=user.get('username', 'User'),
        balance=user.get('balance', 0)
    )

@app.route('/login', methods=['GET', 'POST'])
def login():
    # Placeholder login logic (You need to replace this with your actual login logic)
    if request.method == 'POST':
        # Assuming your login uses a username/password or TG ID
        username = request.form.get('username')
        password = request.form.get('password')
        
        # --- DANGER: DEMO LOGIN LOGIC. REPLACE THIS! ---
        # Assuming username is the unique ID for simplicity.
        user_id = username 
        admin_db = load_db(ADMIN_DB_FILE)
        
        if user_id in admin_db:
            # Simple password check (REPLACE WITH HASHING IN REAL APP)
            if admin_db[user_id].get('password') == password:
                session['user_id'] = user_id
                return redirect(url_for('dashboard'))
            else:
                # Password incorrect
                pass
        else:
            # Register new user for demo purposes if not found
            admin_db[user_id] = {
                'username': username,
                'password': password,
                'balance': 500, # Initial balance
                'is_unlimited': False,
            }
            save_db(admin_db, ADMIN_DB_FILE)
            session['user_id'] = user_id
            return redirect(url_for('dashboard'))
            
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('user_id', None)
    return redirect(url_for('login'))

# --- NEW: COUPON APPLICATION ROUTE ---

@app.route('/apply_coupon', methods=['POST'])
def apply_coupon_route():
    if not is_logged_in():
        return jsonify({'success': False, 'message': 'Please log in first.'}), 401

    data = request.get_json()
    code = data.get('code', '').strip()
    user_id = session['user_id']
    user_data = get_current_user()

    # 1. Check if the user already has unlimited access
    if user_data.get('is_unlimited', False):
        return jsonify({'success': False, 'message': 'You already have unlimited access!'})

    # 2. Check for the secret coupon code
    if code == UNLIMITED_ACCESS_CODE:
        # Grant access and update DB
        if grant_unlimited_access(user_id):
            return jsonify({
                'success': True, 
                'message': 'ðŸ”¥ Congratulations! Unlimited Access UNLOCKED! ðŸ”¥'
            })
        else:
            return jsonify({
                'success': False, 
                'message': 'Error saving access data. Contact admin.'
            })
    else:
        # Invalid code
        return jsonify({'success': False, 'message': 'Invalid coupon code.'})

# --- Placeholder Search Route (You need to implement the actual Telegram search here) ---

@app.route('/search', methods=['POST'])
def search_username_route():
    if not is_logged_in():
        return jsonify({'success': False, 'error': 'Please log in.'}), 401

    user_id = session['user_id']
    user_data = get_current_user()
    
    # 1. Check access
    if not user_data.get('is_unlimited', False) and user_data.get('balance', 0) < SEARCH_PRICE:
        return jsonify({'success': False, 'error': f'Insufficient balance. Need â‚¹{SEARCH_PRICE}.'}), 402

    # 2. Get the username input
    data = request.get_json()
    username = data.get('username', '').strip().replace('@', '')
    
    if not username:
        return jsonify({'success': False, 'error': 'Username cannot be empty.'}), 400

    # 3. Process search (THIS IS WHERE YOUR BOT LOGIC GOES)
    # --- YOUR TELEGRAM BOT SEARCH LOGIC HERE ---
    
    # Placeholder Result (Replace with actual data from your Telegram bot search)
    search_result = {
        'username': '@' + username,
        'full_name': 'Sample User Name',
        'phone_number': '+91XXXXXXXXXX',
        'details': '{"id": 1234567, "is_bot": false, "language_code": "en"}',
        'time': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    # 4. Deduct balance (Only if NOT unlimited)
    if not user_data.get('is_unlimited', False):
        admin_db = load_db(ADMIN_DB_FILE)
        admin_db[user_id]['balance'] -= SEARCH_PRICE
        save_db(admin_db, ADMIN_DB_FILE)
        new_balance = admin_db[user_id]['balance']
    else:
        # Unlimited users don't have balance deducted
        new_balance = user_data.get('balance', 99999999) 

    # 5. Save search history (Optional)
    # searched_db = load_db(SEARCHED_DB_FILE)
    # searched_db.append({'user_id': user_id, 'result': search_result})
    # save_db(searched_db, SEARCHED_DB_FILE)

    return jsonify({
        'success': True,
        'result': search_result,
        'new_balance': new_balance
    })

# --- Run the App ---
if __name__ == '__main__':
    # Flask runs the app on 0.0.0.0 and Koyeb provides the PORT
    # Use gunicorn in production (like in the Dockerfile)
    app.run(host='0.0.0.0', port=PORT, debug=True)
